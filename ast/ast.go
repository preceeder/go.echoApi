package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

var modulePath = flag.String("modulePath", "", "包路径")

func main() {
	flag.Parse()

	p, err := build.Import(*modulePath, "", build.FindOnly)
	if err != nil {
		fmt.Println("模块路径错误:", err)
		return
	}

	data := []string{}
	err = filepath.WalkDir(p.Dir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() || !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}
		if validPath := checkFile(path); len(validPath) > 0 {
			data = append(data, validPath)
		}
		return nil
	})
	if err != nil {
		fmt.Println("遍历目录出错:", err)
		return
	}
	modes := map[string][]string{}
	for _, v := range data {
		lastPath := filepath.Dir(v)
		// 模块名 替换 绝对路径名
		importPath := filepath.ToSlash(strings.TrimPrefix(v, p.Dir+"/"))
		fullImportPath := filepath.Join(p.ImportPath, importPath)

		if !contains(modes[lastPath], fullImportPath) {
			modes[lastPath] = append(modes[lastPath], fullImportPath)
		}
	}

	if err := writeGoFile(modes); err != nil {
		fmt.Println("写入文件失败:", err)
	}
}

// checkFile 检查文件是否包含实现了 Controller 接口的类型
// Controller 接口要求实现 RouteConfig() echoApi.RouteConfig 方法
func checkFile(path string) string {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, path, nil, 0)
	if err != nil {
		fmt.Printf("解析文件失败: %s -> %v\n", path, err)
		return ""
	}

	var hasController bool

	// 遍历 AST，查找实现了 RouteConfig() echoApi.RouteConfig 方法的类型
	ast.Inspect(node, func(n ast.Node) bool {
		// 查找方法声明
		fn, ok := n.(*ast.FuncDecl)
		if !ok {
			return true
		}

		// 检查方法名是否为 RouteConfig
		if fn.Name == nil || fn.Name.Name != "RouteConfig" {
			return true
		}

		// 检查是否有接收者（必须是方法，不是函数）
		if fn.Recv == nil || len(fn.Recv.List) == 0 {
			return true
		}

		// 检查返回类型是否为 echoApi.RouteConfig
		if fn.Type.Results == nil || len(fn.Type.Results.List) == 0 {
			return true
		}

		// 检查返回类型
		for _, result := range fn.Type.Results.List {
			if sel, ok := result.Type.(*ast.SelectorExpr); ok {
				if x, ok := sel.X.(*ast.Ident); ok && x.Name == "echoApi" {
					if sel.Sel.Name == "RouteConfig" {
						hasController = true
						return false // 找到就停止遍历
					}
				}
			}
		}

		return true
	})

	if hasController {
		return filepath.Dir(path)
	}

	return ""
}

func contains(slice []string, target string) bool {
	for _, v := range slice {
		if v == target {
			return true
		}
	}
	return false
}

func getRealPackageName(dir string) (string, error) {
	files, err := os.ReadDir(dir)
	if err != nil {
		return "", err
	}
	for _, file := range files {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".go") {
			fpath := filepath.Join(dir, file.Name())
			fset := token.NewFileSet()
			node, err := parser.ParseFile(fset, fpath, nil, parser.PackageClauseOnly)
			if err == nil {
				return node.Name.Name, nil
			}
		}
	}
	return "", fmt.Errorf("未能解析包名: %s", dir)
}

func writeGoFile(pat map[string][]string) error {
	for k, v := range pat {
		if len(v) == 0 {
			continue
		}
		pkgName, err := getRealPackageName(k)
		if err != nil {
			fmt.Println("获取包名失败：", err)
			continue
		}

		var buffer bytes.Buffer
		buffer.WriteString("// Code generated by gen. DO NOT EDIT.\n\n")
		buffer.WriteString("package " + pkgName + "\n\n")
		buffer.WriteString("import (\n")
		for _, fn := range v {
			buffer.WriteString("    _ \"")
			buffer.WriteString(fn)
			buffer.WriteString("\"\n")
		}
		buffer.WriteString(")\n")

		err = os.WriteFile(filepath.Join(k, "router.go"), buffer.Bytes(), 0644)
		if err != nil {
			fmt.Println("写文件失败:", err)
			return err
		}
	}
	return nil
}
