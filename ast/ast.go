package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

var modulePath = flag.String("modulePath", "", "包路径")

func main() {
	flag.Parse()

	p, err := build.Import(*modulePath, "", build.FindOnly)
	if err != nil {
		fmt.Println("模块路径错误:", err)
		return
	}

	data := []string{}
	err = filepath.WalkDir(p.Dir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() || !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}
		if validPath := checkFile(path); len(validPath) > 0 {
			data = append(data, validPath)
		}
		return nil
	})
	if err != nil {
		fmt.Println("遍历目录出错:", err)
		return
	}
	modes := map[string][]string{}
	for _, v := range data {
		lastPath := filepath.Dir(v)
		// 模块名 替换 绝对路径名
		importPath := filepath.ToSlash(strings.TrimPrefix(v, p.Dir+"/"))
		fullImportPath := filepath.Join(p.ImportPath, importPath)

		if !contains(modes[lastPath], fullImportPath) {
			modes[lastPath] = append(modes[lastPath], fullImportPath)
		}
	}

	if err := writeGoFile(modes); err != nil {
		fmt.Println("写入文件失败:", err)
	}
}

func checkFile(path string) string {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, path, nil, 0)
	if err != nil {
		fmt.Printf("解析文件失败: %s -> %v\n", path, err)
		return ""
	}

	var mud string
	ast.Inspect(node, func(n ast.Node) bool {
		ts, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}
		structType, ok := ts.Type.(*ast.StructType)
		if !ok {
			return true
		}
		for _, field := range structType.Fields.List {
			if t, ok := field.Type.(*ast.SelectorExpr); ok {
				if ident, ok := t.X.(*ast.Ident); ok {
					if ident.Name == "echoApi" && t.Sel.Name == "ApiRouteConfig" {
						mud = filepath.Dir(path)
					}
				}
			}
		}
		return true
	})
	return mud
}

func contains(slice []string, target string) bool {
	for _, v := range slice {
		if v == target {
			return true
		}
	}
	return false
}

func getRealPackageName(dir string) (string, error) {
	files, err := os.ReadDir(dir)
	if err != nil {
		return "", err
	}
	for _, file := range files {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".go") {
			fpath := filepath.Join(dir, file.Name())
			fset := token.NewFileSet()
			node, err := parser.ParseFile(fset, fpath, nil, parser.PackageClauseOnly)
			if err == nil {
				return node.Name.Name, nil
			}
		}
	}
	return "", fmt.Errorf("未能解析包名: %s", dir)
}

func writeGoFile(pat map[string][]string) error {
	for k, v := range pat {
		if len(v) == 0 {
			continue
		}
		pkgName, err := getRealPackageName(k)
		if err != nil {
			fmt.Println("获取包名失败：", err)
			continue
		}

		var buffer bytes.Buffer
		buffer.WriteString("// Code generated by gen. DO NOT EDIT.\n\n")
		buffer.WriteString("package " + pkgName + "\n\n")
		buffer.WriteString("import (\n")
		for _, fn := range v {
			buffer.WriteString("    _ \"")
			buffer.WriteString(fn)
			buffer.WriteString("\"\n")
		}
		buffer.WriteString(")\n")

		err = os.WriteFile(filepath.Join(k, "router.go"), buffer.Bytes(), 0644)
		if err != nil {
			fmt.Println("写文件失败:", err)
			return err
		}
	}
	return nil
}
